module &module:1:0:$full:$large:$default;

/* Test for atomic instructions. */

/* { dg-do compile } */
/* { dg-options "-fdump-tree-gimple" } */

prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %output_ptr)
{
        ld_kernarg_u64 $d0, [%input_ptr];

	atomic_ld_global_rlx_system_b32 $s0, [$d0];
	atomic_add_global_rlx_system_u32 $s1, [$d0 + 4], $s0;

        ld_kernarg_u64 $d0, [%output_ptr];
        atomicnoret_st_global_rlx_system_b32 [$d0], $s2;

	atomicnoret_min_global_rlx_system_u32 [$d0 + 4], $s1;

        ret;
};

/* The atomic loads are implemented by casting to an atomic pointer. */
/* { dg-final { scan-tree-dump "s0 = MEM\\\[\\\(atomic unsigned int \\\*\\\)D.\[0-9\]+\\\];" "gimple"} } */

/* The atomic add should call a gcc builtin. */
/* { dg-final { scan-tree-dump "builtin_out.\[0-9\]+ = __sync_fetch_and_add_4 \\\(D.\[0-9\]+, D.\[0-9\]+\\\);" "gimple"} } */

/* The atomic stores are implemented by casting to an atomic pointer. */
/* { dg-final { scan-tree-dump "MEM\\\[\\\(atomic unsigned int \\\*\\\)D.\[0-9\]+\\\] = s2;" "gimple"} } */

/* The atomic min is implemented by a custom builtin. */
/* { dg-final { scan-tree-dump "builtin_out.\[0-9\]+ = __phsa_builtin_atomic_min_u32 \\\(D.\[0-9\]+, s1\\\);" "gimple"} } */
