module &module:1:0:$full:$large:$default;

/* Tests for load/store addressing modes. */

/* { dg-do compile } */
/* { dg-options "-fdump-tree-gimple" } */

prog kernel &Kernel(kernarg_u64 %input_ptr, kernarg_u64 %input_ptr2, kernarg_u64 %output_ptr)
{
	global_u32 %global_array[4];  

	ld_kernarg_u64 $d0, [%input_ptr];
	ld_kernarg_u64 $d2, [%input_ptr2];
	ld_global_u32 $s0, [$d0];
	ld_global_u64 $d1, [$d2 + 4];

	ld_global_u32 $s2, [%global_array][$d1 + 4];  

	ld_kernarg_u64 $d0, [%output_ptr];
	st_global_u32 $s0, [$d0];
	st_global_u32 $s1, [$d0 + 4];
	st_global_u32 $s2, [$d0 + 8];

	ret;
};

/* %input_ptr, %input_ptr2 and %output_ptr accesses should generate offsets to the __args array */
/* { dg-final { scan-tree-dump " mem_read.\[0-9\]+ = MEM\\\[\\\(unsigned long \\\*\\\)__args\\\];\[\n \]+d0 = mem_read" "gimple"} } */
/* { dg-final { scan-tree-dump "D.\[0-9\]+ = \\\(unsigned long\\\) __args;\[\n \]+D.\[0-9\]+ = D.\[0-9\]+ \\\+ 8;" "gimple"} } */
/* { dg-final { scan-tree-dump "D.\[0-9\]+ = \\\(unsigned long\\\) __args;\[\n \]+D.\[0-9\]+ = D.\[0-9\]+ \\\+ 16;" "gimple"} } */

/* ld_global_u32 $s0, [$d0] */
/* { dg-final { scan-tree-dump "D.\[0-9\]+ = \\\(unsigned char \\\*\\\) d0;\[\n \]+mem_read.\[0-9\]+ = MEM\\\[\\\(unsigned int \\\*\\\)D.\[0-9\]+\\\];\[\n \]+s0 = mem_read.\[0-9\]+;" "gimple"} } */

/* ld_global_u64 $d1, [$d2 + 4] pointer arithmetics*/
/* { dg-final { scan-tree-dump "D.\[0-9\]+ = \\\(unsigned char \\\*\\\) d2;\[\n \]+D.\[0-9\]+ = \\\(unsigned long\\\) D.\[0-9\]+;\[\n \]+D.\[0-9\]+ = D.\[0-9\]+ \\\+ 4;" "gimple"} } */

/* ld_global_u32 $s2, [%global_array][$d1 + 4]; is the most complex form */
/* { dg-final { scan-tree-dump " = \\\(unsigned long\\\) &_Kernel.global_array;\[\n \]+D.\[0-9\]+ = \\\(unsigned char \\\*\\\) d1;\[\n \]+D.\[0-9\]+ = \\\(unsigned long\\\) D.\[0-9\]+;\[\n \]+D.\[0-9\]+ = D.\[0-9\]+ \\\+ 4;\[\n \]+D.\[0-9\]+ = \\\(unsigned int \\\*\\\) D.\[0-9\]+;\[\n \]+D.\[0-9\]+ = \\\(unsigned long\\\) D.\[0-9\]+;\[\n \]+D.\[0-9\]+ = D.\[0-9\]+ \\\+ D.\[0-9\]+;" "gimple" } } */

